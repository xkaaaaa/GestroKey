name: GestroKey CI/CD

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      skip_build:
        description: '跳过实际编译过程 (true/false)'
        required: false
        default: 'false'
        type: boolean

# 为工作流添加权限
permissions:
  contents: write
  packages: read
  issues: read
  pull-requests: read
  actions: write

jobs:
  # 检查提交内容，判断是否需要打包
  check-changes:
    name: 检查代码变更
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check_manual.outputs.changed == 'true' || steps.check_py_changes.outputs.changed == 'true' }}
    
    steps:
      - name: 手动触发检查
        id: check_manual
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "是手动触发的工作流，将执行完整流程"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: 检出代码
        if: steps.check_manual.outputs.changed != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 获取完整的提交历史
      
      - name: 获取上次打包标签
        if: steps.check_manual.outputs.changed != 'true'
        id: last_tag
        run: |
          # 获取所有标签并按时间排序
          tags=$(git tag --sort=-creatordate)
          latest_tag=$(echo "$tags" | grep -v "^latest$" | head -n 1)
          
          if [ -z "$latest_tag" ]; then
            # 如果没有标签，则设置一个初始的SHA
            echo "LAST_TAG=$(git rev-list --max-parents=0 HEAD)" >> $GITHUB_OUTPUT
            echo "没有找到之前的标签，将从首次提交开始检查"
          else
            echo "LAST_TAG=$latest_tag" >> $GITHUB_OUTPUT
            echo "使用最近的标签: $latest_tag"
          fi
      
      - name: 检查是否修改了.py文件
        if: steps.check_manual.outputs.changed != 'true'
        id: check_py_changes
        run: |
          # 如果是手动触发的工作流，直接返回true
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "手动触发工作流，继续构建"
            echo "changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 获取上次发布后修改的文件列表
          files_changed=$(git diff --name-only ${{ steps.last_tag.outputs.LAST_TAG }}..HEAD)
          
          # 检查是否有.py文件被修改
          py_changed=false
          while IFS= read -r file; do
            if [[ "$file" == *.py ]]; then
              py_changed=true
              echo "发现修改的Python文件: $file"
              break
            fi
          done <<< "$files_changed"
          
          # 如果工作流是手动触发的，并且不是要求跳过构建，那么继续构建
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.skip_build }}" != "true" ]]; then
            echo "手动触发工作流，继续构建"
            py_changed=true
          fi
          
          echo "changed=$py_changed" >> $GITHUB_OUTPUT
          
          if [ "$py_changed" == "true" ]; then
            echo "检测到Python文件变更或手动触发，将执行打包流程"
          else
            echo "未检测到Python文件变更，跳过打包流程"
          fi

  # 读取版本信息作为独立任务
  get-version:
    name: 读取版本信息
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.should_build == 'true'
    outputs:
      version: ${{ steps.version_info.outputs.VERSION }}
      version_type: ${{ steps.version_info.outputs.VERSION_TYPE }}
      is_prerelease: ${{ steps.version_info.outputs.IS_PRERELEASE }}
      release_name: ${{ steps.version_info.outputs.RELEASE_NAME }}
      repo_url: ${{ steps.version_info.outputs.REPO_URL }}
      enable_packaging: ${{ steps.package_config.outputs.ENABLE_PACKAGING }}
      package_windows: ${{ steps.package_config.outputs.PACKAGE_WINDOWS }}
      package_macos: ${{ steps.package_config.outputs.PACKAGE_MACOS }}
      package_linux: ${{ steps.package_config.outputs.PACKAGE_LINUX }}
      package_standalone: ${{ steps.package_config.outputs.PACKAGE_STANDALONE }}
      package_portable: ${{ steps.package_config.outputs.PACKAGE_PORTABLE }}
      packager_windows: ${{ steps.package_config.outputs.PACKAGER_WINDOWS }}
      packager_macos: ${{ steps.package_config.outputs.PACKAGER_MACOS }}
      packager_linux: ${{ steps.package_config.outputs.PACKAGER_LINUX }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: 读取版本信息
        id: version_info
        run: |
          # 创建临时脚本读取版本信息
          cat << EOF > temp_version_script.py
          import sys
          from src.version import VERSION, CURRENT_VERSION_TYPE, VERSION_TYPE_RELEASE, VERSION_TYPE_PREVIEW, VERSION_TYPE_DEVELOPMENT, REPO_URL
          
          # 输出版本号
          print(VERSION)
          
          # 输出版本类型（英文）
          if CURRENT_VERSION_TYPE == "未发布版":
              print("development")
          elif CURRENT_VERSION_TYPE == "预览版":
              print("preview")
          elif CURRENT_VERSION_TYPE == "正式版":
              print("release")
          else:
              print("unknown")
              
          # 输出仓库URL
          print(REPO_URL)
          EOF
          
          # 执行脚本并读取输出
          IFS=$'\n' read -d '' -ra outputs < <(python temp_version_script.py && printf '\0')
          version="${outputs[0]}"
          version_type="${outputs[1]}"
          repo_url="${outputs[2]}"
          
          # 删除临时脚本
          rm temp_version_script.py
          
          # 输出版本信息供后续步骤使用
          echo "VERSION=$version" >> $GITHUB_OUTPUT
          echo "REPO_URL=$repo_url" >> $GITHUB_OUTPUT
          
          # 根据英文版本类型判断要创建的release名称和是否为预览版
          if [ "$version_type" = "development" ]; then
            echo "VERSION_TYPE=Development Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=latest" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=true" >> $GITHUB_OUTPUT
          elif [ "$version_type" = "preview" ]; then
            echo "VERSION_TYPE=Preview Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=$version-preview" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=true" >> $GITHUB_OUTPUT
          else
            echo "VERSION_TYPE=Release Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=$version" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=false" >> $GITHUB_OUTPUT
          fi

      - name: 读取打包配置
        id: package_config
        run: |
          # 创建临时脚本读取打包配置
          cat << EOF > temp_package_script.py
          from src.version import ENABLE_PACKAGING, PACKAGE_WINDOWS, PACKAGE_MACOS, PACKAGE_LINUX
          from src.version import PACKAGE_STANDALONE, PACKAGE_PORTABLE
          from src.version import PACKAGER_WINDOWS, PACKAGER_MACOS, PACKAGER_LINUX
          
          # 输出打包控制选项
          print("true" if ENABLE_PACKAGING else "false")
          print("true" if PACKAGE_WINDOWS else "false")
          print("true" if PACKAGE_MACOS else "false")
          print("true" if PACKAGE_LINUX else "false")
          print("true" if PACKAGE_STANDALONE else "false")
          print("true" if PACKAGE_PORTABLE else "false")
          print(PACKAGER_WINDOWS)
          print(PACKAGER_MACOS)
          print(PACKAGER_LINUX)
          EOF
          
          # 执行脚本并读取输出
          IFS=$'\n' read -d '' -ra outputs < <(python temp_package_script.py && printf '\0')
          
          # 输出配置信息供后续步骤使用
          echo "ENABLE_PACKAGING=${outputs[0]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_WINDOWS=${outputs[1]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_MACOS=${outputs[2]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_LINUX=${outputs[3]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_STANDALONE=${outputs[4]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_PORTABLE=${outputs[5]}" >> $GITHUB_OUTPUT
          echo "PACKAGER_WINDOWS=${outputs[6]}" >> $GITHUB_OUTPUT
          echo "PACKAGER_MACOS=${outputs[7]}" >> $GITHUB_OUTPUT
          echo "PACKAGER_LINUX=${outputs[8]}" >> $GITHUB_OUTPUT
          
          # 删除临时脚本
          rm temp_package_script.py

  # 使用矩阵构建不同平台和格式的包
  build:
    name: 构建 ${{ matrix.os }} ${{ matrix.package-type }}
    runs-on: ${{ matrix.os }}
    needs: get-version
    if: needs.get-version.outputs.enable_packaging == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows构建
          - os: windows-latest
            package-type: standalone
            if: ${{ needs.get-version.outputs.package_windows == 'true' && needs.get-version.outputs.package_standalone == 'true' }}
          - os: windows-latest
            package-type: portable
            if: ${{ needs.get-version.outputs.package_windows == 'true' && needs.get-version.outputs.package_portable == 'true' }}
          # Linux构建
          - os: ubuntu-latest
            package-type: standalone
            if: ${{ needs.get-version.outputs.package_linux == 'true' && needs.get-version.outputs.package_standalone == 'true' }}
          - os: ubuntu-latest
            package-type: portable
            if: ${{ needs.get-version.outputs.package_linux == 'true' && needs.get-version.outputs.package_portable == 'true' }}
          # macOS构建
          - os: macos-latest
            package-type: standalone
            if: ${{ needs.get-version.outputs.package_macos == 'true' && needs.get-version.outputs.package_standalone == 'true' }}
          - os: macos-latest
            package-type: portable
            if: ${{ needs.get-version.outputs.package_macos == 'true' && needs.get-version.outputs.package_portable == 'true' }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: macOS - 设置QT_API为pyside6
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # 在macOS上强制使用pyside6
          python -c "
          import sys
          import os
          sys.path.append('src')
          
          # 读取version.py文件
          with open('src/version.py', 'r', encoding='utf-8') as f:
              content = f.read()
          
          # 将QT_API替换为pyside6
          if 'QT_API = \"pyqt6\"' in content:
              content = content.replace('QT_API = \"pyqt6\"', 'QT_API = \"pyside6\"')
          elif 'QT_API = \"pyqt5\"' in content:
              content = content.replace('QT_API = \"pyqt5\"', 'QT_API = \"pyside6\"')
          elif 'QT_API = \"pyside2\"' in content:
              content = content.replace('QT_API = \"pyside2\"', 'QT_API = \"pyside6\"')
          
          # 写回文件
          with open('src/version.py', 'w', encoding='utf-8') as f:
              f.write(content)
          
          print('macOS环境已设置QT_API为pyside6')
          "

      - name: 安装依赖
        shell: bash
        run: |
          python -m pip install --upgrade pip
          pip install nuitka
          pip install -r requirements.txt
          
          # 根据 version.py 中的 QT_API 配置安装对应的 Qt 后端
          QT_API=$(python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)")
          echo "检测到 Qt API: $QT_API"
          
          if [ "$QT_API" = "pyqt5" ]; then
            pip install "PyQt5>=5.15.0" "PyQt5-sip>=12.8.0"
          elif [ "$QT_API" = "pyside6" ]; then
            pip install "PySide6>=6.5.0"
          elif [ "$QT_API" = "pyside2" ]; then
            pip install "PySide2>=5.15.0"
          fi
          
      # 为macOS安装PyInstaller
      - name: macOS - 安装PyInstaller
        if: matrix.os == 'macos-latest'
        run: |
          pip install pyinstaller
          
      # Windows特定安装
      - name: Windows - 安装工具
        if: matrix.os == 'windows-latest'
        run: |
          choco install imagemagick -y

      # macOS特定安装
      - name: macOS - 安装工具
        if: matrix.os == 'macos-latest'
        run: |
          brew install imagemagick

      # Linux特定安装
      - name: Linux - 安装工具
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick fakeroot



      # 构建多文件便携版 - Windows (Nuitka)
      - name: 构建便携版 - Windows (Nuitka)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'nuitka'
        shell: pwsh
        run: |
          $QT_API = python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)"
          Write-Host "检测到 Qt API: $QT_API"
          python -m nuitka --standalone --enable-plugin=$QT_API --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --windows-icon-from-ico=src/assets/images/icons/icon.ico --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          Copy-Item -Path dist/main.dist/* -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/" -Recurse
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 构建多文件便携版 - Windows (PyInstaller)
      - name: 构建便携版 - Windows (PyInstaller)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'pyinstaller'
        shell: pwsh
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --windowed --noconfirm --add-data="src/assets;assets" --add-data="src/ui/settings/default_settings.json;ui/settings" --add-data="src/ui/gestures/default_gestures.json;ui/gestures" --icon=src/assets/images/icons/icon.ico src/main.py
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          Copy-Item -Path dist/GestroKey/* -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/" -Recurse
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 构建多文件便携版 - Linux (Nuitka)
      - name: 构建便携版 - Linux (Nuitka)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'nuitka'
        shell: bash
        run: |
          QT_API=$(python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)")
          echo "检测到 Qt API: $QT_API"
          python -m nuitka --standalone --enable-plugin=$QT_API --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          cp -r dist/main.dist/* "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 构建多文件便携版 - Linux (PyInstaller)
      - name: 构建便携版 - Linux (PyInstaller)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'pyinstaller'
        shell: bash
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --windowed --noconfirm --add-data="src/assets:assets" --add-data="src/ui/settings/default_settings.json:ui/settings" --add-data="src/ui/gestures/default_gestures.json:ui/gestures" src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          cp -r dist/GestroKey/* "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 构建多文件便携版 - macOS (Nuitka)
      - name: 构建便携版 - macOS (Nuitka)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest' && needs.get-version.outputs.packager_macos == 'nuitka'
        shell: bash
        run: |
          QT_API=$(python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)")
          echo "检测到 Qt API: $QT_API"
          python -m nuitka --mode=app --enable-plugin=$QT_API --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          cp -r dist/main.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/GestroKey.app"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 构建多文件便携版 - macOS (使用PyInstaller)
      - name: 构建便携版 - macOS (PyInstaller)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest' && needs.get-version.outputs.packager_macos == 'pyinstaller'
        shell: bash
        run: |
          # 创建spec文件
          cat > GestroKey.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          
          a = Analysis(
              ['src/main.py'],
              pathex=[],
              binaries=[],
              datas=[
                  ('src/assets', 'assets'),
                  ('src/ui/settings/default_settings.json', 'ui/settings'),
                  ('src/ui/gestures/default_gestures.json', 'ui/gestures')
              ],
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              noarchive=False,
          )
          
          pyz = PYZ(a.pure)
          
          exe = EXE(
              pyz,
              a.scripts,
              [],
              exclude_binaries=True,
              name='GestroKey',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='src/assets/images/icons/icon.icns',
          )
          
          coll = COLLECT(
              exe,
              a.binaries,
              a.datas,
              strip=False,
              upx=True,
              upx_exclude=[],
              name='GestroKey',
          )
          
          app = BUNDLE(
              coll,
              name='GestroKey.app',
              icon='src/assets/images/icons/icon.icns',
              bundle_identifier=None,
              info_plist={
                  'NSHighResolutionCapable': 'True',
                  'CFBundleShortVersionString': '${{ needs.get-version.outputs.version }}',
                  'CFBundleVersion': '${{ needs.get-version.outputs.version }}',
                  'CFBundleName': 'GestroKey',
                  'CFBundleDisplayName': 'GestroKey',
                  'CFBundleExecutable': 'GestroKey',
              },
          )
          EOF
          
          # 使用PyInstaller构建
          pyinstaller GestroKey.spec
          
          # 打包
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          cp -r dist/GestroKey.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 构建单文件版本 - Windows
      - name: 构建单文件版 - Windows (Nuitka)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'nuitka'
        shell: pwsh
        run: |
          $QT_API = python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)"
          Write-Host "检测到 Qt API: $QT_API"
          python -m nuitka --onefile --enable-plugin=$QT_API --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --windows-icon-from-ico=src/assets/images/icons/icon.ico --output-dir=dist --assume-yes-for-downloads src/main.py
          Move-Item -Path dist/main.exe -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 构建单文件版本 - Windows (PyInstaller)
      - name: 构建单文件版 - Windows (PyInstaller)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'pyinstaller'
        shell: pwsh
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --onefile --windowed --noconfirm --add-data="src/assets;assets" --add-data="src/ui/settings/default_settings.json;ui/settings" --add-data="src/ui/gestures/default_gestures.json;ui/gestures" --icon=src/assets/images/icons/icon.ico src/main.py
          Move-Item -Path dist/GestroKey.exe -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 构建单文件版本 - Linux
      - name: 构建单文件版 - Linux (Nuitka)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'nuitka'
        shell: bash
        run: |
          QT_API=$(python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)")
          echo "检测到 Qt API: $QT_API"
          python -m nuitka --onefile --enable-plugin=$QT_API --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mv dist/main.bin "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 构建单文件版本 - Linux (PyInstaller)
      - name: 构建单文件版 - Linux (PyInstaller)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'pyinstaller'
        shell: bash
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --onefile --windowed --noconfirm --add-data="src/assets:assets" --add-data="src/ui/settings/default_settings.json:ui/settings" --add-data="src/ui/gestures/default_gestures.json:ui/gestures" src/main.py
          mv dist/GestroKey "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 构建单文件版本 - macOS (Nuitka)
      - name: 构建单文件版 - macOS (Nuitka)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest' && needs.get-version.outputs.packager_macos == 'nuitka'
        shell: bash
        run: |
          QT_API=$(python -c "import sys; sys.path.append('src'); from version import QT_API; print(QT_API)")
          echo "检测到 Qt API: $QT_API"
          python -m nuitka --mode=app --enable-plugin=$QT_API --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          cp -r dist/main.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone/GestroKey.app"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 构建单文件版本 - macOS (使用PyInstaller)
      - name: 构建单文件版 - macOS (PyInstaller)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest' && needs.get-version.outputs.packager_macos == 'pyinstaller'
        shell: bash
        run: |
          # 创建spec文件
          cat > GestroKey_onefile.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          
          a = Analysis(
              ['src/main.py'],
              pathex=[],
              binaries=[],
              datas=[
                  ('src/assets', 'assets'),
                  ('src/ui/settings/default_settings.json', 'ui/settings'),
                  ('src/ui/gestures/default_gestures.json', 'ui/gestures')
              ],
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              noarchive=False,
          )
          
          pyz = PYZ(a.pure)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.datas,
              [],
              name='GestroKey',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='src/assets/images/icons/icon.icns',
          )
          
          app = BUNDLE(
              exe,
              name='GestroKey.app',
              icon='src/assets/images/icons/icon.icns',
              bundle_identifier=None,
              info_plist={
                  'NSHighResolutionCapable': 'True',
                  'CFBundleShortVersionString': '${{ needs.get-version.outputs.version }}',
                  'CFBundleVersion': '${{ needs.get-version.outputs.version }}',
                  'CFBundleName': 'GestroKey',
                  'CFBundleDisplayName': 'GestroKey',
                  'CFBundleExecutable': 'GestroKey',
              },
          )
          EOF
          
          # 使用PyInstaller构建
          pyinstaller GestroKey_onefile.spec
          
          # 打包
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          cp -r dist/GestroKey.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone/GestroKey.app"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 模拟构建便携版（跳过实际编译）- Windows
      - name: 模拟构建便携版（跳过实际编译）- Windows
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "跳过编译过程，创建Windows便携版虚拟包..."
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          "模拟构建" | Out-File -FilePath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/README.txt"
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 模拟构建便携版（跳过实际编译）- Linux
      - name: 模拟构建便携版（跳过实际编译）- Linux
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建Linux便携版虚拟包..."
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/README.txt"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 模拟构建便携版（跳过实际编译）- macOS
      - name: 模拟构建便携版（跳过实际编译）- macOS
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建macOS便携版虚拟包..."
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/README.txt"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 模拟构建单文件版（跳过实际编译）- Windows
      - name: 模拟构建单文件版（跳过实际编译）- Windows
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "跳过编译过程，创建Windows单文件版虚拟包..."
          mkdir -Force -Path dist
          "模拟构建" | Out-File -FilePath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 模拟构建单文件版（跳过实际编译）- Linux
      - name: 模拟构建单文件版（跳过实际编译）- Linux
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建Linux单文件版虚拟包..."
          mkdir -p dist
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 模拟构建单文件版（跳过实际编译）- macOS
      - name: 模拟构建单文件版（跳过实际编译）- macOS
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建macOS单文件版虚拟包..."
          mkdir -p dist
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 上传构建产物
      - name: 上传构建产物
        uses: actions/upload-artifact@v4
        with:
          name: GestroKey-${{ needs.get-version.outputs.version }}-${{ matrix.os }}-${{ matrix.package-type }}
          path: |
            dist/GestroKey-*.exe
            dist/GestroKey-*.zip
            dist/GestroKey-*.dmg
            dist/GestroKey-*.tar.gz
            dist/GestroKey-*-Standalone
            dist/GestroKey-*-Standalone.exe

  # 创建发布
  release:
    name: 创建版本发布
    runs-on: ubuntu-latest
    needs: [get-version, build, check-changes]
    if: always() && needs.check-changes.outputs.should_build == 'true' && needs.get-version.outputs.enable_packaging == 'true'
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史记录以便获取所有标签和提交

      - name: 下载所有构建产物
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: 列出所有文件
        run: find artifacts -type f | sort

      - name: 获取提交记录并生成更新日志
        id: generate_changelog
        run: |
          # 根据版本类型确定上一个版本标签
          version_type="${{ needs.get-version.outputs.version_type }}"
          current_tag="${{ needs.get-version.outputs.release_name }}"
          
          # 获取所有标签并按版本排序
          all_tags=$(git tag -l | grep -v "latest" | sort -V)
          
          # 根据版本类型查找上一个版本标签
          if [[ "$version_type" == "Development Version" ]]; then
            # 未发布版：目前最新的版本
            previous_tag=$(echo "$all_tags" | tail -n 1)
          elif [[ "$version_type" == "Preview Version" ]]; then
            # 预览版：除latest外的最新版本
            previous_tag=$(echo "$all_tags" | grep -v "$current_tag" | tail -n 1)
          else
            # 发行版：上一个发行版
            previous_tag=$(echo "$all_tags" | grep -v "preview" | grep -v "$current_tag" | tail -n 1)
          fi
          
          # 如果没有找到上一个版本标签，则不生成更新日志
          if [[ -z "$previous_tag" || "$previous_tag" == "$current_tag" ]]; then
            echo "没有找到上一个版本标签，跳过更新日志生成"
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            echo "该版本为首个发布版本，无更新日志。" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "当前版本：$current_tag，上一版本：$previous_tag"
          
          # 获取提交记录
          commits=$(git log --pretty=format:"%s" $previous_tag..HEAD)
          
          # 初始化各个部分的内容
          features=""
          fixes=""
          docs=""
          styles=""
          refactors=""
          performances=""
          tests=""
          chores=""
          breaking_changes=""
          others=""
          
          # 定义关联数组来存储已添加的描述，用于去重
          declare -A added_breaking_changes
          declare -A added_features
          declare -A added_fixes
          declare -A added_docs
          declare -A added_styles
          declare -A added_refactors
          declare -A added_performances
          declare -A added_tests
          declare -A added_chores
          declare -A added_others
          
          # 解析 Conventional Commits 格式的提交信息
          while IFS= read -r commit; do
            # 检查是否包含破坏性变更标记
            if [[ "$commit" =~ ^[a-zA-Z]+(\(.+\))?!:.*$ ]] || [[ "$commit" =~ BREAKING[[:space:]]CHANGE ]]; then
              # 提取描述部分（去掉类型前缀）
              description=$(echo "$commit" | sed -E 's/^[a-zA-Z]+(\(.+\))?!?:[[:space:]]*//')
              if [[ -z "${added_breaking_changes[$description]}" ]]; then
                breaking_changes="${breaking_changes}- ${description}\n"
                added_breaking_changes["$description"]=1
              fi
            elif [[ "$commit" =~ ^feat(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_features[$description]}" ]]; then
                features="${features}- ${description}\n"
                added_features["$description"]=1
              fi
            elif [[ "$commit" =~ ^fix(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_fixes[$description]}" ]]; then
                fixes="${fixes}- ${description}\n"
                added_fixes["$description"]=1
              fi
            elif [[ "$commit" =~ ^docs(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_docs[$description]}" ]]; then
                docs="${docs}- ${description}\n"
                added_docs["$description"]=1
              fi
            elif [[ "$commit" =~ ^style(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_styles[$description]}" ]]; then
                styles="${styles}- ${description}\n"
                added_styles["$description"]=1
              fi
            elif [[ "$commit" =~ ^refactor(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_refactors[$description]}" ]]; then
                refactors="${refactors}- ${description}\n"
                added_refactors["$description"]=1
              fi
            elif [[ "$commit" =~ ^perf(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_performances[$description]}" ]]; then
                performances="${performances}- ${description}\n"
                added_performances["$description"]=1
              fi
            elif [[ "$commit" =~ ^test(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_tests[$description]}" ]]; then
                tests="${tests}- ${description}\n"
                added_tests["$description"]=1
              fi
            elif [[ "$commit" =~ ^chore(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              description="${BASH_REMATCH[2]}"
              if [[ -z "${added_chores[$description]}" ]]; then
                chores="${chores}- ${description}\n"
                added_chores["$description"]=1
              fi
            elif [[ "$commit" =~ ^(build|ci|revert)(\(.+\))?:[[:space:]]*(.+)$ ]]; then
              # 将 build、ci、revert 归类到其他变更
              description="${BASH_REMATCH[3]}"
              if [[ -z "${added_others[$description]}" ]]; then
                others="${others}- ${description}\n"
                added_others["$description"]=1
              fi
            else
              # 不符合 Conventional Commits 格式的提交，归类到其他变更
              description="$commit"
              if [[ -z "${added_others[$description]}" ]]; then
                others="${others}- ${description}\n"
                added_others["$description"]=1
              fi
            fi
          done <<< "$commits"
          
          # 生成更新日志
          changelog="## 更新日志\n\n"
          
          # 破坏性变更（最重要，放在最前面）
          if [[ -n "$breaking_changes" ]]; then
            changelog="${changelog}### ⚠️ 破坏性变更\n\n${breaking_changes}\n"
          fi
          
          # 新功能
          if [[ -n "$features" ]]; then
            changelog="${changelog}### ✨ 新功能\n\n${features}\n"
          fi
          
          # 问题修复
          if [[ -n "$fixes" ]]; then
            changelog="${changelog}### 🐛 问题修复\n\n${fixes}\n"
          fi
          
          # 性能优化
          if [[ -n "$performances" ]]; then
            changelog="${changelog}### ⚡ 性能优化\n\n${performances}\n"
          fi
          
          # 代码重构
          if [[ -n "$refactors" ]]; then
            changelog="${changelog}### ♻️ 代码重构\n\n${refactors}\n"
          fi
          
          # 文档更新
          if [[ -n "$docs" ]]; then
            changelog="${changelog}### 📝 文档更新\n\n${docs}\n"
          fi
          
          # 代码风格
          if [[ -n "$styles" ]]; then
            changelog="${changelog}### 💄 代码风格\n\n${styles}\n"
          fi
          
          # 测试相关
          if [[ -n "$tests" ]]; then
            changelog="${changelog}### 🧪 测试相关\n\n${tests}\n"
          fi
          
          # 构建和维护
          if [[ -n "$chores" ]]; then
            changelog="${changelog}### 🔧 构建和维护\n\n${chores}\n"
          fi
          
          # 其他变更
          if [[ -n "$others" ]]; then
            changelog="${changelog}### 📦 其他变更\n\n${others}\n"
          fi
          
          # 如果没有任何变更记录，显示提示信息
          if [[ "$breaking_changes" == "" && "$features" == "" && "$fixes" == "" && "$docs" == "" && "$styles" == "" && "$refactors" == "" && "$performances" == "" && "$tests" == "" && "$chores" == "" && "$others" == "" ]]; then
            changelog="${changelog}*本次版本更新未包含符合 Conventional Commits 格式的提交信息*\n"
          fi
          
          # 输出更新日志给后续步骤使用
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo -e "$changelog" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 生成下载链接表格和说明
        id: generate_table
        run: |
          # 根据版本类型设置不同的标题和内容
          if [[ "${{ needs.get-version.outputs.version_type }}" == "Development Version" ]]; then
            # 未发布版本使用简化格式
            echo "# GestroKey 开发版 ${{ needs.get-version.outputs.version }}" > release_description.md
            echo "" >> release_description.md
            echo "此版本为自动构建的最新开发版本，请谨慎使用。" >> release_description.md
            echo "" >> release_description.md
            
            # 仅添加简化版更新日志
            echo "## 更新日志" >> release_description.md
            echo "" >> release_description.md
            echo -e "${{ steps.generate_changelog.outputs.CHANGELOG }}" | grep -v "## 更新日志" >> release_description.md
            
            # 添加构建信息
            echo "" >> release_description.md
            echo "---" >> release_description.md
            echo "构建时间: $(date '+%Y-%m-%d %H:%M:%S')" >> release_description.md
          else
            # 正式版和预览版保持原有格式
            echo "" > release_description.md
            echo "## 下载链接" >> release_description.md
            echo "" >> release_description.md
            echo "| 操作系统 | 单文件版 | 便携版 |" >> release_description.md
            echo "|---------|---------|-------|" >> release_description.md
            echo "| Windows | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe) | [ZIP压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip) |" >> release_description.md
            echo "| macOS   | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone) | [ZIP压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip) |" >> release_description.md
            echo "| Linux   | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone) | [TAR.GZ压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz) |" >> release_description.md
            echo "" >> release_description.md
            
            # 添加系统要求
            echo "## 系统要求" >> release_description.md
            echo "" >> release_description.md
            echo "- **Windows**: Windows 10/11 64位" >> release_description.md
            echo "- **macOS**: macOS 11.0+ (Big Sur及更高版本)" >> release_description.md
            echo "- **Linux**: 主流桌面发行版 (Ubuntu 20.04+, Fedora 36+, Debian 11+)" >> release_description.md
            echo "" >> release_description.md
            
            # 添加更新日志
            echo -e "${{ steps.generate_changelog.outputs.CHANGELOG }}" >> release_description.md
            
            # 添加构建信息
            echo "" >> release_description.md
            echo "---" >> release_description.md
            echo "" >> release_description.md
            echo "此版本由GitHub Actions自动构建于 $(date '+%Y-%m-%d %H:%M:%S %Z')" >> release_description.md
          fi
          
          # 输出完整内容给后续步骤使用
          echo "DESCRIPTION<<EOF" >> $GITHUB_OUTPUT
          cat release_description.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 检查标签是否存在
      - name: 检查标签是否存在
        id: check_tag
        uses: mukunku/tag-exists-action@v1.4.0
        with:
          tag: ${{ needs.get-version.outputs.release_name }}

      # 删除已存在的release和标签
      - name: 删除已存在的release和标签
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "移除已存在的标签: ${{ needs.get-version.outputs.release_name }}"
          
          # 使用GitHub CLI删除release和标签
          gh release delete ${{ needs.get-version.outputs.release_name }} --yes || echo "Release不存在或无法删除"
          
          # 删除远程标签
          git tag -d ${{ needs.get-version.outputs.release_name }} || echo "本地标签不存在"
          git push --delete origin ${{ needs.get-version.outputs.release_name }} || echo "远程标签不存在或无法删除"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      # 当发布正式版或预览版时删除latest标签
      - name: 删除latest标签
        if: needs.get-version.outputs.version_type != 'Development Version'
        run: |
          echo "发布正式版或预览版，删除latest标签"
          
          # 检查latest标签是否存在
          if git ls-remote --tags origin | grep -q "refs/tags/latest"; then
            # 删除GitHub Release
            gh release delete latest --yes || echo "Release latest不存在或无法删除"
            
            # 删除远程标签
            git push --delete origin latest || echo "远程标签latest不存在或无法删除"
          else
            # 兼容性检查：也尝试删除旧的latest标签
            if git ls-remote --tags origin | grep -q "refs/tags/latest"; then
              gh release delete latest --yes || echo "Release latest不存在或无法删除"
              git push --delete origin latest || echo "远程标签latest不存在或无法删除"
            else
              echo "标签latest不存在，无需删除"
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 创建并推送标签
      - name: 创建并推送标签
        run: |
          # 创建标签
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          echo "创建标签: ${{ needs.get-version.outputs.release_name }}"
          git tag -a ${{ needs.get-version.outputs.release_name }} -m "Release ${{ needs.get-version.outputs.release_name }}"
          
          # 推送标签
          git push origin ${{ needs.get-version.outputs.release_name }}

      # 创建Release
      - name: 创建Release
        uses: softprops/action-gh-release@v1
        with:
          name: ${{ needs.get-version.outputs.release_name }}
          tag_name: ${{ needs.get-version.outputs.release_name }}
          body: ${{ steps.generate_table.outputs.DESCRIPTION }}
          prerelease: ${{ needs.get-version.outputs.is_prerelease }}
          files: artifacts/*