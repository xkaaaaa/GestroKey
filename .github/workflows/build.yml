name: GestroKey CI/CD

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      skip_build:
        description: '跳过实际编译过程 (true/false)'
        required: false
        default: 'false'
        type: boolean

# 为工作流添加权限
permissions:
  contents: write
  packages: read
  issues: read
  pull-requests: read

jobs:
  # 读取版本信息作为独立任务
  get-version:
    name: 读取版本信息
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version_info.outputs.VERSION }}
      version_type: ${{ steps.version_info.outputs.VERSION_TYPE }}
      is_prerelease: ${{ steps.version_info.outputs.IS_PRERELEASE }}
      release_name: ${{ steps.version_info.outputs.RELEASE_NAME }}
      repo_url: ${{ steps.version_info.outputs.REPO_URL }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: 读取版本信息
        id: version_info
        run: |
          # 创建临时脚本读取版本信息
          cat << EOF > temp_version_script.py
          import sys
          from src.version import VERSION, CURRENT_VERSION_TYPE, VERSION_TYPE_RELEASE, VERSION_TYPE_PREVIEW, VERSION_TYPE_DEVELOPMENT, REPO_URL
          
          # 输出版本号
          print(VERSION)
          
          # 输出版本类型（英文）
          if CURRENT_VERSION_TYPE == "未发布版":
              print("development")
          elif CURRENT_VERSION_TYPE == "预览版":
              print("preview")
          elif CURRENT_VERSION_TYPE == "正式版":
              print("release")
          else:
              print("unknown")
              
          # 输出仓库URL
          print(REPO_URL)
          EOF
          
          # 执行脚本并读取输出
          IFS=$'\n' read -d '' -ra outputs < <(python temp_version_script.py && printf '\0')
          version="${outputs[0]}"
          version_type="${outputs[1]}"
          repo_url="${outputs[2]}"
          
          # 删除临时脚本
          rm temp_version_script.py
          
          # 输出版本信息供后续步骤使用
          echo "VERSION=$version" >> $GITHUB_OUTPUT
          echo "REPO_URL=$repo_url" >> $GITHUB_OUTPUT
          
          # 根据英文版本类型判断要创建的release名称和是否为预览版
          if [ "$version_type" = "development" ]; then
            echo "VERSION_TYPE=Development Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=latest" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=true" >> $GITHUB_OUTPUT
          elif [ "$version_type" = "preview" ]; then
            echo "VERSION_TYPE=Preview Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=$version-preview" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=true" >> $GITHUB_OUTPUT
          else
            echo "VERSION_TYPE=Release Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=$version" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=false" >> $GITHUB_OUTPUT
          fi

  # 使用矩阵构建不同平台和格式的包
  build:
    name: 构建 ${{ matrix.os }} ${{ matrix.package-type }}
    runs-on: ${{ matrix.os }}
    needs: get-version
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
        package-type: [standalone, portable]
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install nuitka
          pip install -r requirements.txt
          
      # 为macOS安装PyInstaller
      - name: macOS - 安装PyInstaller
        if: matrix.os == 'macos-latest'
        run: |
          pip install pyinstaller
          
      # Windows特定安装
      - name: Windows - 安装工具
        if: matrix.os == 'windows-latest'
        run: |
          choco install imagemagick -y

      # macOS特定安装
      - name: macOS - 安装工具
        if: matrix.os == 'macos-latest'
        run: |
          brew install imagemagick

      # Linux特定安装
      - name: Linux - 安装工具
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick fakeroot

      # 处理图标 - Windows
      - name: Windows - 处理图标
        if: matrix.os == 'windows-latest'
        run: |
          if (-Not (Test-Path -Path "src/assets/images")) {
            mkdir -p src/assets/images
          }
          if (Test-Path -Path src/assets/images/icon.svg) {
            magick src/assets/images/icon.svg -background none -resize 256x256 icon-256.png
            magick src/assets/images/icon.svg -background none -resize 128x128 icon-128.png
            magick src/assets/images/icon.svg -background none -resize 64x64 icon-64.png
            magick src/assets/images/icon.svg -background none -resize 48x48 icon-48.png
            magick src/assets/images/icon.svg -background none -resize 32x32 icon-32.png
            magick src/assets/images/icon.svg -background none -resize 16x16 icon-16.png
            magick icon-256.png icon-128.png icon-64.png icon-48.png icon-32.png icon-16.png src/assets/images/icon.ico
            Remove-Item icon-*.png
          } else {
            Write-Error "缺少图标文件: src/assets/images/icon.svg"
            exit 1
          }

      # 处理图标 - macOS
      - name: macOS - 处理图标
        if: matrix.os == 'macos-latest'
        run: |
          if [ ! -d "src/assets/images" ]; then
            mkdir -p src/assets/images
          fi
          if [ -f src/assets/images/icon.svg ]; then
            # 创建正确的iconset目录
            mkdir -p "iconset.iconset"
            # 使用magick命令替代convert
            for size in 16 32 64 128 256 512 1024; do
              magick src/assets/images/icon.svg -background none -resize ${size}x${size} "iconset.iconset/icon_${size}x${size}.png"
              # 为Retina显示创建@2x版本
              if [ "$size" -le "512" ]; then
                dsize=$((size*2))
                magick src/assets/images/icon.svg -background none -resize ${dsize}x${dsize} "iconset.iconset/icon_${size}x${size}@2x.png"
              fi
            done
            # 使用正确格式创建icns文件
            iconutil -c icns -o src/assets/images/icon.icns "iconset.iconset"
            rm -rf "iconset.iconset"
          else
            echo "缺少图标文件: src/assets/images/icon.svg"
            exit 1
          fi

      # 处理图标 - Linux
      - name: Linux - 处理图标
        if: matrix.os == 'ubuntu-latest'
        run: |
          if [ ! -d "src/assets/images" ]; then
            mkdir -p src/assets/images
          fi
          if [ -f src/assets/images/icon.svg ]; then
            convert -background none src/assets/images/icon.svg -resize 256x256 src/assets/images/icon.png
          else
            echo "缺少图标文件: src/assets/images/icon.svg"
            exit 1
          fi

      # 构建多文件便携版 - Windows
      - name: 构建便携版 - Windows
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          python -m nuitka --standalone --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --windows-icon-from-ico=src/assets/images/icon.ico --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          Copy-Item -Path dist/main.dist/* -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/" -Recurse
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 构建多文件便携版 - Linux
      - name: 构建便携版 - Linux
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          python -m nuitka --standalone --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          cp -r dist/main.dist/* "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 构建多文件便携版 - macOS (使用PyInstaller)
      - name: 构建便携版 - macOS
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          # 创建spec文件
          cat > GestroKey.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          
          a = Analysis(
              ['src/main.py'],
              pathex=[],
              binaries=[],
              datas=[
                  ('src/assets', 'assets'),
                  ('src/ui/settings/default_settings.json', 'ui/settings'),
                  ('src/ui/gestures/default_gestures.json', 'ui/gestures')
              ],
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              noarchive=False,
          )
          
          pyz = PYZ(a.pure)
          
          exe = EXE(
              pyz,
              a.scripts,
              [],
              exclude_binaries=True,
              name='GestroKey',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='src/assets/images/icon.icns',
          )
          
          coll = COLLECT(
              exe,
              a.binaries,
              a.datas,
              strip=False,
              upx=True,
              upx_exclude=[],
              name='GestroKey',
          )
          
          app = BUNDLE(
              coll,
              name='GestroKey.app',
              icon='src/assets/images/icon.icns',
              bundle_identifier=None,
              info_plist={
                  'NSHighResolutionCapable': 'True',
                  'CFBundleShortVersionString': '${{ needs.get-version.outputs.version }}',
                  'CFBundleVersion': '${{ needs.get-version.outputs.version }}',
                  'CFBundleName': 'GestroKey',
                  'CFBundleDisplayName': 'GestroKey',
                  'CFBundleExecutable': 'GestroKey',
              },
          )
          EOF
          
          # 使用PyInstaller构建
          pyinstaller GestroKey.spec
          
          # 打包
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          cp -r dist/GestroKey.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 构建单文件版本 - Windows
      - name: 构建单文件版 - Windows
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          python -m nuitka --onefile --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --windows-icon-from-ico=src/assets/images/icon.ico --output-dir=dist --assume-yes-for-downloads src/main.py
          Move-Item -Path dist/main.exe -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 构建单文件版本 - Linux
      - name: 构建单文件版 - Linux
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          python -m nuitka --onefile --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mv dist/main.bin "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 构建单文件版本 - macOS (使用PyInstaller)
      - name: 构建单文件版 - macOS
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          # 创建spec文件
          cat > GestroKey_onefile.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          
          a = Analysis(
              ['src/main.py'],
              pathex=[],
              binaries=[],
              datas=[
                  ('src/assets', 'assets'),
                  ('src/ui/settings/default_settings.json', 'ui/settings'),
                  ('src/ui/gestures/default_gestures.json', 'ui/gestures')
              ],
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              noarchive=False,
          )
          
          pyz = PYZ(a.pure)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.datas,
              [],
              name='GestroKey',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='src/assets/images/icon.icns',
          )
          
          app = BUNDLE(
              exe,
              name='GestroKey.app',
              icon='src/assets/images/icon.icns',
              bundle_identifier=None,
              info_plist={
                  'NSHighResolutionCapable': 'True',
                  'CFBundleShortVersionString': '${{ needs.get-version.outputs.version }}',
                  'CFBundleVersion': '${{ needs.get-version.outputs.version }}',
                  'CFBundleName': 'GestroKey',
                  'CFBundleDisplayName': 'GestroKey',
                  'CFBundleExecutable': 'GestroKey',
              },
          )
          EOF
          
          # 使用PyInstaller构建
          pyinstaller GestroKey_onefile.spec
          
          # 打包
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          cp -r dist/GestroKey.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone/GestroKey.app"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 模拟构建便携版（跳过实际编译）- Windows
      - name: 模拟构建便携版（跳过实际编译）- Windows
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "跳过编译过程，创建Windows便携版虚拟包..."
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          "模拟构建" | Out-File -FilePath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/README.txt"
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 模拟构建便携版（跳过实际编译）- Linux
      - name: 模拟构建便携版（跳过实际编译）- Linux
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建Linux便携版虚拟包..."
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/README.txt"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 模拟构建便携版（跳过实际编译）- macOS
      - name: 模拟构建便携版（跳过实际编译）- macOS
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建macOS便携版虚拟包..."
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/README.txt"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 模拟构建单文件版（跳过实际编译）- Windows
      - name: 模拟构建单文件版（跳过实际编译）- Windows
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "跳过编译过程，创建Windows单文件版虚拟包..."
          mkdir -Force -Path dist
          "模拟构建" | Out-File -FilePath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 模拟构建单文件版（跳过实际编译）- Linux
      - name: 模拟构建单文件版（跳过实际编译）- Linux
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建Linux单文件版虚拟包..."
          mkdir -p dist
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 模拟构建单文件版（跳过实际编译）- macOS
      - name: 模拟构建单文件版（跳过实际编译）- macOS
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建macOS单文件版虚拟包..."
          mkdir -p dist
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 上传构建产物
      - name: 上传构建产物
        uses: actions/upload-artifact@v4
        with:
          name: GestroKey-${{ needs.get-version.outputs.version }}-${{ matrix.os }}-${{ matrix.package-type }}
          path: |
            dist/GestroKey-*.exe
            dist/GestroKey-*.zip
            dist/GestroKey-*.dmg
            dist/GestroKey-*.tar.gz
            dist/GestroKey-*-Standalone
            dist/GestroKey-*-Standalone.exe

  # 创建发布
  release:
    name: 创建版本发布
    runs-on: ubuntu-latest
    needs: [get-version, build]
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史记录以便获取所有标签和提交

      - name: 下载所有构建产物
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: 列出所有文件
        run: find artifacts -type f | sort

      - name: 获取提交记录并生成更新日志
        id: generate_changelog
        run: |
          # 根据版本类型确定上一个版本标签
          version_type="${{ needs.get-version.outputs.version_type }}"
          current_tag="${{ needs.get-version.outputs.release_name }}"
          
          # 获取所有标签并按版本排序
          all_tags=$(git tag -l | grep -v "latest" | sort -V)
          
          # 根据版本类型查找上一个版本标签
          if [[ "$version_type" == "Development Version" ]]; then
            # 未发布版：目前最新的版本
            previous_tag=$(echo "$all_tags" | tail -n 1)
          elif [[ "$version_type" == "Preview Version" ]]; then
            # 预览版：除latest外的最新版本
            previous_tag=$(echo "$all_tags" | grep -v "$current_tag" | tail -n 1)
          else
            # 发行版：上一个发行版
            previous_tag=$(echo "$all_tags" | grep -v "preview" | grep -v "$current_tag" | tail -n 1)
          fi
          
          # 如果没有找到上一个版本标签，则不生成更新日志
          if [[ -z "$previous_tag" || "$previous_tag" == "$current_tag" ]]; then
            echo "没有找到上一个版本标签，跳过更新日志生成"
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            echo "该版本为首个发布版本，无更新日志。" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "当前版本：$current_tag，上一版本：$previous_tag"
          
          # 获取提交记录
          commits=$(git log --pretty=format:"%s" $previous_tag..HEAD)
          
          # 初始化三个部分的内容
          new_features=""
          fixes=""
          improvements=""
          
          # 解析提交信息
          while IFS= read -r commit; do
            if [[ "$commit" =~ ^新增：(.+) ]]; then
              new_features="${new_features}- ${BASH_REMATCH[1]}\n"
            elif [[ "$commit" =~ ^修复：(.+) ]]; then
              fixes="${fixes}- ${BASH_REMATCH[1]}\n"
            elif [[ "$commit" =~ ^改进：(.+) ]]; then
              improvements="${improvements}- ${BASH_REMATCH[1]}\n"
            fi
          done <<< "$commits"
          
          # 生成更新日志
          changelog="## 更新日志\n\n"
          
          if [[ -n "$new_features" ]]; then
            changelog="${changelog}### 新增功能\n\n${new_features}\n"
          fi
          
          if [[ -n "$fixes" ]]; then
            changelog="${changelog}### 问题修复\n\n${fixes}\n"
          fi
          
          if [[ -n "$improvements" ]]; then
            changelog="${changelog}### 功能改进\n\n${improvements}\n"
          fi
          
          if [[ "$new_features" == "" && "$fixes" == "" && "$improvements" == "" ]]; then
            changelog="${changelog}*本次版本更新未包含符合格式要求的提交信息*\n"
          fi
          
          # 输出更新日志给后续步骤使用
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo -e "$changelog" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 生成下载链接表格和说明
        id: generate_table
        run: |
          # 生成包含下载链接和更新日志的完整内容
          echo "# GestroKey ${{ needs.get-version.outputs.version }} ${{ needs.get-version.outputs.version_type }}" > release_description.md
          echo "" >> release_description.md
          echo "## 下载链接" >> release_description.md
          echo "" >> release_description.md
          echo "| 操作系统 | 单文件版 | 便携版 |" >> release_description.md
          echo "|---------|---------|-------|" >> release_description.md
          echo "| Windows | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe) | [ZIP压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip) |" >> release_description.md
          echo "| macOS   | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone) | [ZIP压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip) |" >> release_description.md
          echo "| Linux   | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone) | [TAR.GZ压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz) |" >> release_description.md
          echo "" >> release_description.md
          
          # 添加系统要求
          echo "## 系统要求" >> release_description.md
          echo "" >> release_description.md
          echo "- **Windows**: Windows 10/11 64位" >> release_description.md
          echo "- **macOS**: macOS 11.0+ (Big Sur及更高版本)" >> release_description.md
          echo "- **Linux**: 主流桌面发行版 (Ubuntu 20.04+, Fedora 36+, Debian 11+)" >> release_description.md
          echo "" >> release_description.md
          
          # 添加更新日志
          echo -e "${{ steps.generate_changelog.outputs.CHANGELOG }}" >> release_description.md
          
          # 添加构建信息
          echo "" >> release_description.md
          echo "---" >> release_description.md
          echo "" >> release_description.md
          echo "此版本由GitHub Actions自动构建于 $(date '+%Y-%m-%d %H:%M:%S %Z')" >> release_description.md
          
          # 输出完整内容给后续步骤使用
          echo "DESCRIPTION<<EOF" >> $GITHUB_OUTPUT
          cat release_description.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 检查标签是否存在
      - name: 检查标签是否存在
        id: check_tag
        uses: mukunku/tag-exists-action@v1.4.0
        with:
          tag: ${{ needs.get-version.outputs.release_name }}

      # 删除已存在的release和标签
      - name: 删除已存在的release和标签
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "移除已存在的标签: ${{ needs.get-version.outputs.release_name }}"
          
          # 使用GitHub CLI删除release和标签
          gh release delete ${{ needs.get-version.outputs.release_name }} --yes || echo "Release不存在或无法删除"
          
          # 删除远程标签
          git tag -d ${{ needs.get-version.outputs.release_name }} || echo "本地标签不存在"
          git push --delete origin ${{ needs.get-version.outputs.release_name }} || echo "远程标签不存在或无法删除"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 创建并推送标签
      - name: 创建并推送标签
        run: |
          # 创建标签
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          echo "创建标签: ${{ needs.get-version.outputs.release_name }}"
          git tag -a ${{ needs.get-version.outputs.release_name }} -m "Release ${{ needs.get-version.outputs.release_name }}"
          
          # 推送标签
          git push origin ${{ needs.get-version.outputs.release_name }}

      # 创建Release
      - name: 创建Release
        uses: softprops/action-gh-release@v1
        with:
          name: ${{ needs.get-version.outputs.release_name }}
          tag_name: ${{ needs.get-version.outputs.release_name }}
          body: ${{ steps.generate_table.outputs.DESCRIPTION }}
          prerelease: ${{ needs.get-version.outputs.is_prerelease }}
          files: artifacts/*