name: GestroKey CI/CD

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      skip_build:
        description: '跳过实际编译过程 (true/false)'
        required: false
        default: 'false'
        type: boolean

# 为工作流添加权限
permissions:
  contents: write
  packages: read
  issues: read
  pull-requests: read

jobs:
  # 检查提交内容，判断是否需要打包
  check-changes:
    name: 检查代码变更
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check_py_changes.outputs.changed }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 获取完整的提交历史
      
      - name: 获取上次打包标签
        id: last_tag
        run: |
          # 获取所有标签并按时间排序
          tags=$(git tag --sort=-creatordate)
          latest_tag=$(echo "$tags" | grep -v "^latest$" | head -n 1)
          
          if [ -z "$latest_tag" ]; then
            # 如果没有标签，则设置一个初始的SHA
            echo "LAST_TAG=$(git rev-list --max-parents=0 HEAD)" >> $GITHUB_OUTPUT
            echo "没有找到之前的标签，将从首次提交开始检查"
          else
            echo "LAST_TAG=$latest_tag" >> $GITHUB_OUTPUT
            echo "使用最近的标签: $latest_tag"
          fi
      
      - name: 检查是否修改了.py文件
        id: check_py_changes
        run: |
          # 获取上次发布后修改的文件列表
          files_changed=$(git diff --name-only ${{ steps.last_tag.outputs.LAST_TAG }}..HEAD)
          
          # 检查是否有.py文件被修改
          py_changed=false
          while IFS= read -r file; do
            if [[ "$file" == *.py ]]; then
              py_changed=true
              echo "发现修改的Python文件: $file"
              break
            fi
          done <<< "$files_changed"
          
          # 如果工作流是手动触发的，并且不是要求跳过构建，那么继续构建
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.skip_build }}" != "true" ]]; then
            echo "手动触发工作流，继续构建"
            py_changed=true
          fi
          
          echo "changed=$py_changed" >> $GITHUB_OUTPUT
          
          if [ "$py_changed" == "true" ]; then
            echo "检测到Python文件变更，将执行打包流程"
          else
            echo "未检测到Python文件变更，跳过打包流程"
          fi

  # 读取版本信息作为独立任务
  get-version:
    name: 读取版本信息
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.should_build == 'true'
    outputs:
      version: ${{ steps.version_info.outputs.VERSION }}
      version_type: ${{ steps.version_info.outputs.VERSION_TYPE }}
      is_prerelease: ${{ steps.version_info.outputs.IS_PRERELEASE }}
      release_name: ${{ steps.version_info.outputs.RELEASE_NAME }}
      repo_url: ${{ steps.version_info.outputs.REPO_URL }}
      enable_packaging: ${{ steps.package_config.outputs.ENABLE_PACKAGING }}
      package_windows: ${{ steps.package_config.outputs.PACKAGE_WINDOWS }}
      package_macos: ${{ steps.package_config.outputs.PACKAGE_MACOS }}
      package_linux: ${{ steps.package_config.outputs.PACKAGE_LINUX }}
      package_standalone: ${{ steps.package_config.outputs.PACKAGE_STANDALONE }}
      package_portable: ${{ steps.package_config.outputs.PACKAGE_PORTABLE }}
      packager_windows: ${{ steps.package_config.outputs.PACKAGER_WINDOWS }}
      packager_macos: ${{ steps.package_config.outputs.PACKAGER_MACOS }}
      packager_linux: ${{ steps.package_config.outputs.PACKAGER_LINUX }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: 读取版本信息
        id: version_info
        run: |
          # 创建临时脚本读取版本信息
          cat << EOF > temp_version_script.py
          import sys
          from src.version import VERSION, CURRENT_VERSION_TYPE, VERSION_TYPE_RELEASE, VERSION_TYPE_PREVIEW, VERSION_TYPE_DEVELOPMENT, REPO_URL
          
          # 输出版本号
          print(VERSION)
          
          # 输出版本类型（英文）
          if CURRENT_VERSION_TYPE == "未发布版":
              print("development")
          elif CURRENT_VERSION_TYPE == "预览版":
              print("preview")
          elif CURRENT_VERSION_TYPE == "正式版":
              print("release")
          else:
              print("unknown")
              
          # 输出仓库URL
          print(REPO_URL)
          EOF
          
          # 执行脚本并读取输出
          IFS=$'\n' read -d '' -ra outputs < <(python temp_version_script.py && printf '\0')
          version="${outputs[0]}"
          version_type="${outputs[1]}"
          repo_url="${outputs[2]}"
          
          # 删除临时脚本
          rm temp_version_script.py
          
          # 输出版本信息供后续步骤使用
          echo "VERSION=$version" >> $GITHUB_OUTPUT
          echo "REPO_URL=$repo_url" >> $GITHUB_OUTPUT
          
          # 根据英文版本类型判断要创建的release名称和是否为预览版
          if [ "$version_type" = "development" ]; then
            echo "VERSION_TYPE=Development Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=999.999.999-latest" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=true" >> $GITHUB_OUTPUT
          elif [ "$version_type" = "preview" ]; then
            echo "VERSION_TYPE=Preview Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=$version-preview" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=true" >> $GITHUB_OUTPUT
          else
            echo "VERSION_TYPE=Release Version" >> $GITHUB_OUTPUT
            echo "RELEASE_NAME=$version" >> $GITHUB_OUTPUT
            echo "IS_PRERELEASE=false" >> $GITHUB_OUTPUT
          fi

      - name: 读取打包配置
        id: package_config
        run: |
          # 创建临时脚本读取打包配置
          cat << EOF > temp_package_script.py
          from src.version import ENABLE_PACKAGING, PACKAGE_WINDOWS, PACKAGE_MACOS, PACKAGE_LINUX
          from src.version import PACKAGE_STANDALONE, PACKAGE_PORTABLE
          from src.version import PACKAGER_WINDOWS, PACKAGER_MACOS, PACKAGER_LINUX
          
          # 输出打包控制选项
          print("true" if ENABLE_PACKAGING else "false")
          print("true" if PACKAGE_WINDOWS else "false")
          print("true" if PACKAGE_MACOS else "false")
          print("true" if PACKAGE_LINUX else "false")
          print("true" if PACKAGE_STANDALONE else "false")
          print("true" if PACKAGE_PORTABLE else "false")
          print(PACKAGER_WINDOWS)
          print(PACKAGER_MACOS)
          print(PACKAGER_LINUX)
          EOF
          
          # 执行脚本并读取输出
          IFS=$'\n' read -d '' -ra outputs < <(python temp_package_script.py && printf '\0')
          
          # 输出配置信息供后续步骤使用
          echo "ENABLE_PACKAGING=${outputs[0]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_WINDOWS=${outputs[1]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_MACOS=${outputs[2]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_LINUX=${outputs[3]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_STANDALONE=${outputs[4]}" >> $GITHUB_OUTPUT
          echo "PACKAGE_PORTABLE=${outputs[5]}" >> $GITHUB_OUTPUT
          echo "PACKAGER_WINDOWS=${outputs[6]}" >> $GITHUB_OUTPUT
          echo "PACKAGER_MACOS=${outputs[7]}" >> $GITHUB_OUTPUT
          echo "PACKAGER_LINUX=${outputs[8]}" >> $GITHUB_OUTPUT
          
          # 删除临时脚本
          rm temp_package_script.py

  # 添加自动化测试任务
  run-tests:
    name: 运行自动化测试
    runs-on: ubuntu-latest
    needs: [check-changes, get-version]
    if: needs.check-changes.outputs.should_build == 'true'
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
      
      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: 安装测试依赖
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-mock coverage-badge anybadge
      
      - name: 运行测试并收集覆盖率
        run: |
          pytest tests --cov=src --cov-report=xml --cov-report=html --verbose
      
      - name: 生成覆盖率报告
        run: |
          coverage report
          coverage xml
          
          # 生成覆盖率徽章
          coverage_value=$(python -c "import xml.etree.ElementTree as ET; print(ET.parse('coverage.xml').getroot().get('line-rate'))")
          coverage_percentage=$(python -c "print(round(float($coverage_value) * 100))")
          
          echo "代码覆盖率: $coverage_percentage%"
          
          # 生成覆盖率徽章
          anybadge --value=$coverage_percentage --file=coverage-badge.svg --label=coverage --color=green:90 yellow:70 orange:50 red:0
      
      - name: 上传覆盖率报告
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            htmlcov/
            coverage.xml
            coverage-badge.svg
          retention-days: 7
          
      - name: 总结测试结果
        run: |
          echo "测试已完成，所有测试都通过"
          echo "代码覆盖率报告已生成，可在构建产物中查看"

  # 使用矩阵构建不同平台和格式的包
  build:
    name: 构建 ${{ matrix.os }} ${{ matrix.package-type }}
    runs-on: ${{ matrix.os }}
    needs: [get-version, run-tests, code-quality, security-scan]
    if: needs.get-version.outputs.enable_packaging == 'true' && always() && needs.run-tests.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows构建
          - os: windows-latest
            package-type: standalone
            if: ${{ needs.get-version.outputs.package_windows == 'true' && needs.get-version.outputs.package_standalone == 'true' }}
          - os: windows-latest
            package-type: portable
            if: ${{ needs.get-version.outputs.package_windows == 'true' && needs.get-version.outputs.package_portable == 'true' }}
          # Linux构建
          - os: ubuntu-latest
            package-type: standalone
            if: ${{ needs.get-version.outputs.package_linux == 'true' && needs.get-version.outputs.package_standalone == 'true' }}
          - os: ubuntu-latest
            package-type: portable
            if: ${{ needs.get-version.outputs.package_linux == 'true' && needs.get-version.outputs.package_portable == 'true' }}
          # macOS构建
          - os: macos-latest
            package-type: standalone
            if: ${{ needs.get-version.outputs.package_macos == 'true' && needs.get-version.outputs.package_standalone == 'true' }}
          - os: macos-latest
            package-type: portable
            if: ${{ needs.get-version.outputs.package_macos == 'true' && needs.get-version.outputs.package_portable == 'true' }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
          
      # 缓存优化 - 保存pip下载的包
      - name: 缓存pip包
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            ${{ env.pythonLocation }}
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
            
      # 缓存优化 - Nuitka编译缓存
      - name: 缓存Nuitka编译
        uses: actions/cache@v3
        if: contains(fromJSON('["nuitka"]'), needs.get-version.outputs.packager_windows) || contains(fromJSON('["nuitka"]'), needs.get-version.outputs.packager_linux)
        with:
          path: |
            ~/.cache/Nuitka
            ~/.cache/ccache
          key: ${{ runner.os }}-nuitka-${{ hashFiles('src/**/*.py') }}
          restore-keys: |
            ${{ runner.os }}-nuitka-
            
      # 缓存优化 - PyInstaller编译缓存
      - name: 缓存PyInstaller
        uses: actions/cache@v3
        if: contains(fromJSON('["pyinstaller"]'), needs.get-version.outputs.packager_windows) || contains(fromJSON('["pyinstaller"]'), needs.get-version.outputs.packager_linux) || matrix.os == 'macos-latest'
        with:
          path: |
            ~/.cache/PyInstaller
          key: ${{ runner.os }}-pyinstaller-${{ hashFiles('src/**/*.py') }}
          restore-keys: |
            ${{ runner.os }}-pyinstaller-
            
      # 优化 - 安装ccache用于编译加速
      - name: 安装ccache (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            sudo apt-get update
            sudo apt-get install -y ccache
          elif [ "${{ matrix.os }}" = "macos-latest" ]; then
            brew install ccache
          fi
          echo "PATH=/usr/lib/ccache:$PATH" >> $GITHUB_ENV
          
      # 优化 - 配置ccache (Linux/macOS)
      - name: 配置ccache (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          ccache -M 500M
          ccache -s

      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install nuitka setuptools wheel
          pip install -r requirements.txt
          
      # 为macOS安装PyInstaller
      - name: macOS - 安装PyInstaller
        if: matrix.os == 'macos-latest'
        run: |
          pip install pyinstaller
          
      # Windows特定安装
      - name: Windows - 安装工具
        if: matrix.os == 'windows-latest'
        run: |
          choco install imagemagick -y

      # macOS特定安装
      - name: macOS - 安装工具
        if: matrix.os == 'macos-latest'
        run: |
          brew install imagemagick

      # Linux特定安装
      - name: Linux - 安装工具
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick fakeroot

      # 处理图标 - Windows
      - name: Windows - 处理图标
        if: matrix.os == 'windows-latest'
        run: |
          if (-Not (Test-Path -Path "src/assets/images")) {
            mkdir -p src/assets/images
          }
          if (Test-Path -Path src/assets/images/icon.svg) {
            # 确保使用24位PNG格式并保留alpha通道
            magick src/assets/images/icon.svg -background transparent -define png:color-type=6 -resize 256x256 icon-256.png
            magick src/assets/images/icon.svg -background transparent -define png:color-type=6 -resize 128x128 icon-128.png
            magick src/assets/images/icon.svg -background transparent -define png:color-type=6 -resize 64x64 icon-64.png
            magick src/assets/images/icon.svg -background transparent -define png:color-type=6 -resize 48x48 icon-48.png
            magick src/assets/images/icon.svg -background transparent -define png:color-type=6 -resize 32x32 icon-32.png
            magick src/assets/images/icon.svg -background transparent -define png:color-type=6 -resize 16x16 icon-16.png
            
            # 使用转换后的PNG文件创建带透明度的ICO文件
            magick convert icon-256.png icon-128.png icon-64.png icon-48.png icon-32.png icon-16.png -alpha on -background transparent src/assets/images/icon.ico
            
            Remove-Item icon-*.png
          } else {
            Write-Error "缺少图标文件: src/assets/images/icon.svg"
            exit 1
          }

      # 处理图标 - macOS
      - name: macOS - 处理图标
        if: matrix.os == 'macos-latest'
        run: |
          if [ ! -d "src/assets/images" ]; then
            mkdir -p src/assets/images
          fi
          if [ -f src/assets/images/icon.svg ]; then
            # 创建正确的iconset目录
            mkdir -p "iconset.iconset"
            # 使用magick命令替代convert
            for size in 16 32 64 128 256 512 1024; do
              magick src/assets/images/icon.svg -background none -resize ${size}x${size} "iconset.iconset/icon_${size}x${size}.png"
              # 为Retina显示创建@2x版本
              if [ "$size" -le "512" ]; then
                dsize=$((size*2))
                magick src/assets/images/icon.svg -background none -resize ${dsize}x${dsize} "iconset.iconset/icon_${size}x${size}@2x.png"
              fi
            done
            # 使用正确格式创建icns文件
            iconutil -c icns -o src/assets/images/icon.icns "iconset.iconset"
            rm -rf "iconset.iconset"
          else
            echo "缺少图标文件: src/assets/images/icon.svg"
            exit 1
          fi

      # 处理图标 - Linux
      - name: Linux - 处理图标
        if: matrix.os == 'ubuntu-latest'
        run: |
          if [ ! -d "src/assets/images" ]; then
            mkdir -p src/assets/images
          fi
          if [ -f src/assets/images/icon.svg ]; then
            convert -background none src/assets/images/icon.svg -resize 256x256 src/assets/images/icon.png
          else
            echo "缺少图标文件: src/assets/images/icon.svg"
            exit 1
          fi

      # 构建多文件便携版 - Windows (Nuitka)
      - name: 构建便携版 - Windows (Nuitka)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'nuitka'
        shell: pwsh
        run: |
          python -m nuitka --standalone --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --windows-icon-from-ico=src/assets/images/icon.ico --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          Copy-Item -Path dist/main.dist/* -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/" -Recurse
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 构建多文件便携版 - Windows (PyInstaller)
      - name: 构建便携版 - Windows (PyInstaller)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'pyinstaller'
        shell: pwsh
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --windowed --noconfirm --add-data="src/assets;assets" --add-data="src/ui/settings/default_settings.json;ui/settings" --add-data="src/ui/gestures/default_gestures.json;ui/gestures" --icon=src/assets/images/icon.ico src/main.py
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          Copy-Item -Path dist/GestroKey/* -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/" -Recurse
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 构建多文件便携版 - Linux (Nuitka)
      - name: 构建便携版 - Linux (Nuitka)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'nuitka'
        shell: bash
        run: |
          python -m nuitka --standalone --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          cp -r dist/main.dist/* "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 构建多文件便携版 - Linux (PyInstaller)
      - name: 构建便携版 - Linux (PyInstaller)
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'pyinstaller'
        shell: bash
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --windowed --noconfirm --add-data="src/assets:assets" --add-data="src/ui/settings/default_settings.json:ui/settings" --add-data="src/ui/gestures/default_gestures.json:ui/gestures" src/main.py
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          cp -r dist/GestroKey/* "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 构建多文件便携版 - macOS (使用PyInstaller)
      - name: 构建便携版 - macOS
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest' && needs.get-version.outputs.packager_macos == 'pyinstaller'
        shell: bash
        run: |
          # 创建spec文件
          cat > GestroKey.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          
          a = Analysis(
              ['src/main.py'],
              pathex=[],
              binaries=[],
              datas=[
                  ('src/assets', 'assets'),
                  ('src/ui/settings/default_settings.json', 'ui/settings'),
                  ('src/ui/gestures/default_gestures.json', 'ui/gestures')
              ],
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              noarchive=False,
          )
          
          pyz = PYZ(a.pure)
          
          exe = EXE(
              pyz,
              a.scripts,
              [],
              exclude_binaries=True,
              name='GestroKey',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='src/assets/images/icon.icns',
          )
          
          coll = COLLECT(
              exe,
              a.binaries,
              a.datas,
              strip=False,
              upx=True,
              upx_exclude=[],
              name='GestroKey',
          )
          
          app = BUNDLE(
              coll,
              name='GestroKey.app',
              icon='src/assets/images/icon.icns',
              bundle_identifier=None,
              info_plist={
                  'NSHighResolutionCapable': 'True',
                  'CFBundleShortVersionString': '${{ needs.get-version.outputs.version }}',
                  'CFBundleVersion': '${{ needs.get-version.outputs.version }}',
                  'CFBundleName': 'GestroKey',
                  'CFBundleDisplayName': 'GestroKey',
                  'CFBundleExecutable': 'GestroKey',
              },
          )
          EOF
          
          # 使用PyInstaller构建
          pyinstaller GestroKey.spec
          
          # 打包
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          cp -r dist/GestroKey.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 构建单文件版本 - Windows
      - name: 构建单文件版 - Windows (Nuitka)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'nuitka'
        shell: pwsh
        run: |
          python -m nuitka --onefile --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --windows-icon-from-ico=src/assets/images/icon.ico --output-dir=dist --assume-yes-for-downloads src/main.py
          Move-Item -Path dist/main.exe -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 构建单文件版本 - Windows (PyInstaller)
      - name: 构建单文件版 - Windows (PyInstaller)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'windows-latest' && needs.get-version.outputs.packager_windows == 'pyinstaller'
        shell: pwsh
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --onefile --windowed --noconfirm --add-data="src/assets;assets" --add-data="src/ui/settings/default_settings.json;ui/settings" --add-data="src/ui/gestures/default_gestures.json;ui/gestures" --icon=src/assets/images/icon.ico src/main.py
          Move-Item -Path dist/GestroKey.exe -Destination "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 构建单文件版本 - Linux
      - name: 构建单文件版 - Linux (Nuitka)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'nuitka'
        shell: bash
        run: |
          python -m nuitka --onefile --enable-plugin=pyqt6 --include-data-dir=src/assets=assets --include-data-files=src/ui/settings/default_settings.json=ui/settings/default_settings.json --include-data-files=src/ui/gestures/default_gestures.json=ui/gestures/default_gestures.json --output-dir=dist --assume-yes-for-downloads src/main.py
          mv dist/main.bin "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 构建单文件版本 - Linux (PyInstaller)
      - name: 构建单文件版 - Linux (PyInstaller)
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'ubuntu-latest' && needs.get-version.outputs.packager_linux == 'pyinstaller'
        shell: bash
        run: |
          pip install pyinstaller
          pyinstaller --name=GestroKey --onefile --windowed --noconfirm --add-data="src/assets:assets" --add-data="src/ui/settings/default_settings.json:ui/settings" --add-data="src/ui/gestures/default_gestures.json:ui/gestures" src/main.py
          mv dist/GestroKey "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 构建单文件版本 - macOS (使用PyInstaller)
      - name: 构建单文件版 - macOS
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build != 'true' && matrix.os == 'macos-latest' && needs.get-version.outputs.packager_macos == 'pyinstaller'
        shell: bash
        run: |
          # 创建spec文件
          cat > GestroKey_onefile.spec << EOF
          # -*- mode: python ; coding: utf-8 -*-
          
          a = Analysis(
              ['src/main.py'],
              pathex=[],
              binaries=[],
              datas=[
                  ('src/assets', 'assets'),
                  ('src/ui/settings/default_settings.json', 'ui/settings'),
                  ('src/ui/gestures/default_gestures.json', 'ui/gestures')
              ],
              hiddenimports=[],
              hookspath=[],
              hooksconfig={},
              runtime_hooks=[],
              excludes=[],
              noarchive=False,
          )
          
          pyz = PYZ(a.pure)
          
          exe = EXE(
              pyz,
              a.scripts,
              a.binaries,
              a.datas,
              [],
              name='GestroKey',
              debug=False,
              bootloader_ignore_signals=False,
              strip=False,
              upx=True,
              upx_exclude=[],
              runtime_tmpdir=None,
              console=False,
              disable_windowed_traceback=False,
              argv_emulation=True,
              target_arch=None,
              codesign_identity=None,
              entitlements_file=None,
              icon='src/assets/images/icon.icns',
          )
          
          app = BUNDLE(
              exe,
              name='GestroKey.app',
              icon='src/assets/images/icon.icns',
              bundle_identifier=None,
              info_plist={
                  'NSHighResolutionCapable': 'True',
                  'CFBundleShortVersionString': '${{ needs.get-version.outputs.version }}',
                  'CFBundleVersion': '${{ needs.get-version.outputs.version }}',
                  'CFBundleName': 'GestroKey',
                  'CFBundleDisplayName': 'GestroKey',
                  'CFBundleExecutable': 'GestroKey',
              },
          )
          EOF
          
          # 使用PyInstaller构建
          pyinstaller GestroKey_onefile.spec
          
          # 打包
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          cp -r dist/GestroKey.app "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone/GestroKey.app"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 模拟构建便携版（跳过实际编译）- Windows
      - name: 模拟构建便携版（跳过实际编译）- Windows
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "跳过编译过程，创建Windows便携版虚拟包..."
          mkdir -Force -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable"
          "模拟构建" | Out-File -FilePath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/README.txt"
          Compress-Archive -Path "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable/*" -DestinationPath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip" -Force

      # 模拟构建便携版（跳过实际编译）- Linux
      - name: 模拟构建便携版（跳过实际编译）- Linux
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建Linux便携版虚拟包..."
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable/README.txt"
          cd dist && tar -czvf "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz" "GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable"

      # 模拟构建便携版（跳过实际编译）- macOS
      - name: 模拟构建便携版（跳过实际编译）- macOS
        if: matrix.package-type == 'portable' && github.event.inputs.skip_build == 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建macOS便携版虚拟包..."
          mkdir -p "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable/README.txt"
          cd dist && zip -r "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip" "GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable"

      # 模拟构建单文件版（跳过实际编译）- Windows
      - name: 模拟构建单文件版（跳过实际编译）- Windows
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          echo "跳过编译过程，创建Windows单文件版虚拟包..."
          mkdir -Force -Path dist
          "模拟构建" | Out-File -FilePath "dist/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe"

      # 模拟构建单文件版（跳过实际编译）- Linux
      - name: 模拟构建单文件版（跳过实际编译）- Linux
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建Linux单文件版虚拟包..."
          mkdir -p dist
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone"

      # 模拟构建单文件版（跳过实际编译）- macOS
      - name: 模拟构建单文件版（跳过实际编译）- macOS
        if: matrix.package-type == 'standalone' && github.event.inputs.skip_build == 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo "跳过编译过程，创建macOS单文件版虚拟包..."
          mkdir -p dist
          echo "模拟构建" > "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"
          chmod +x "dist/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone"

      # 上传构建产物
      - name: 上传构建产物
        uses: actions/upload-artifact@v4
        with:
          name: GestroKey-${{ needs.get-version.outputs.version }}-${{ matrix.os }}-${{ matrix.package-type }}
          path: |
            dist/GestroKey-*.exe
            dist/GestroKey-*.zip
            dist/GestroKey-*.dmg
            dist/GestroKey-*.tar.gz
            dist/GestroKey-*-Standalone
            dist/GestroKey-*-Standalone.exe

  # 创建发布
  release:
    name: 创建版本发布
    runs-on: ubuntu-latest
    needs: [get-version, build, check-changes]
    if: always() && needs.check-changes.outputs.should_build == 'true' && needs.get-version.outputs.enable_packaging == 'true'
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史记录以便获取所有标签和提交

      - name: 下载所有构建产物
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: 列出所有文件
        run: find artifacts -type f | sort

      - name: 获取提交记录并生成更新日志
        id: generate_changelog
        run: |
          # 根据版本类型确定上一个版本标签
          version_type="${{ needs.get-version.outputs.version_type }}"
          current_tag="${{ needs.get-version.outputs.release_name }}"
          current_version="${{ needs.get-version.outputs.version }}"
          
          # 获取所有标签并按版本排序
          all_tags=$(git tag -l | grep -v "latest" | grep -v "999.999.999-latest" | sort -V)
          
          # 根据版本类型查找上一个版本标签
          if [[ "$version_type" == "Development Version" ]]; then
            # 未发布版：目前最新的版本
            previous_tag=$(echo "$all_tags" | tail -n 1)
          elif [[ "$version_type" == "Preview Version" ]]; then
            # 预览版：除latest外的最新版本
            previous_tag=$(echo "$all_tags" | grep -v "$current_tag" | tail -n 1)
          else
            # 发行版：上一个发行版
            previous_tag=$(echo "$all_tags" | grep -v "preview" | grep -v "$current_tag" | tail -n 1)
          fi
          
          # 如果没有找到上一个版本标签，则不生成更新日志
          if [[ -z "$previous_tag" || "$previous_tag" == "$current_tag" ]]; then
            echo "没有找到上一个版本标签，跳过更新日志生成"
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            echo "<div align='center'><h2>🎉 首次发布</h2></div>" >> $GITHUB_OUTPUT
            echo "<p>这是GestroKey的首个版本，无更新日志。</p>" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "当前版本：$current_tag，上一版本：$previous_tag"
          
          # 获取提交记录
          commits=$(git log --pretty=format:"%h|%an|%at|%s" $previous_tag..HEAD)
          
          # 初始化各类别的内容
          new_features=""
          fixes=""
          improvements=""
          others=""
          
          # 获取时间
          current_date=$(date "+%Y-%m-%d")
          
          # 解析提交信息
          while IFS= read -r commit; do
            # 分解提交信息
            hash=$(echo "$commit" | cut -d'|' -f1)
            author=$(echo "$commit" | cut -d'|' -f2)
            timestamp=$(echo "$commit" | cut -d'|' -f3)
            message=$(echo "$commit" | cut -d'|' -f4)
            
            # 格式化日期
            commit_date=$(date -d @$timestamp "+%Y-%m-%d")
            
            # 提交链接
            commit_link="[\`${hash:0:7}\`](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${hash})"
            
            # 根据提交消息类型分类
            if [[ "$message" =~ ^新增：(.+) ]]; then
              content="${BASH_REMATCH[1]}"
              new_features="${new_features}- **${content}** ${commit_link} - *${commit_date}*\n"
            elif [[ "$message" =~ ^修复：(.+) ]]; then
              content="${BASH_REMATCH[1]}"
              fixes="${fixes}- **${content}** ${commit_link} - *${commit_date}*\n"
            elif [[ "$message" =~ ^改进：(.+) ]]; then
              content="${BASH_REMATCH[1]}"
              improvements="${improvements}- **${content}** ${commit_link} - *${commit_date}*\n"
            else
              others="${others}- ${message} ${commit_link} - *${commit_date}*\n"
            fi
          done <<< "$commits"
          
          # 生成美观的更新日志
          changelog="<div align='center'><h2>📋 更新日志</h2></div>\n\n"
          changelog="${changelog}<p align='right'><i>发布于: ${current_date}</i></p>\n\n"
          changelog="${changelog}<p>版本 <b>${current_version}</b> 相比 <b>${previous_tag}</b> 的变更：</p>\n\n"
          
          if [[ -n "$new_features" ]]; then
            changelog="${changelog}<details open>\n<summary><h3>✨ 新增功能</h3></summary>\n\n${new_features}\n</details>\n\n"
          fi
          
          if [[ -n "$fixes" ]]; then
            changelog="${changelog}<details open>\n<summary><h3>🐛 问题修复</h3></summary>\n\n${fixes}\n</details>\n\n"
          fi
          
          if [[ -n "$improvements" ]]; then
            changelog="${changelog}<details open>\n<summary><h3>⚡ 功能改进</h3></summary>\n\n${improvements}\n</details>\n\n"
          fi
          
          if [[ -n "$others" ]]; then
            changelog="${changelog}<details>\n<summary><h3>🔄 其它变更</h3></summary>\n\n${others}\n</details>\n\n"
          fi
          
          if [[ "$new_features" == "" && "$fixes" == "" && "$improvements" == "" && "$others" == "" ]]; then
            changelog="${changelog}*本次版本更新未包含符合格式要求的提交信息*\n"
          fi
          
          # 输出更新日志给后续步骤使用
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo -e "$changelog" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 生成下载链接表格和说明
        id: generate_table
        run: |
          # 根据版本类型设置不同的标题
          if [[ "${{ needs.get-version.outputs.version_type }}" == "Development Version" ]]; then
            echo "# 🚧 GestroKey 最新开发构建 (未发布版本)" > release_description.md
            echo "" >> release_description.md
            echo "**版本号:** ${{ needs.get-version.outputs.version }}" >> release_description.md
            echo "**警告:** 此版本为自动构建的最新开发版本，可能包含不稳定功能和已知问题" >> release_description.md
          else
            echo "# GestroKey ${{ needs.get-version.outputs.version }} ${{ needs.get-version.outputs.version_type }}" > release_description.md
          fi
          
          echo "" >> release_description.md
          echo "## 下载链接" >> release_description.md
          echo "" >> release_description.md
          echo "| 操作系统 | 单文件版 | 便携版 |" >> release_description.md
          echo "|---------|---------|-------|" >> release_description.md
          echo "| Windows | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Standalone.exe) | [ZIP压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Windows-Portable.zip) |" >> release_description.md
          echo "| macOS   | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Standalone) | [ZIP压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-macOS-Portable.zip) |" >> release_description.md
          echo "| Linux   | [独立可执行文件](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Standalone) | [TAR.GZ压缩包](${{ needs.get-version.outputs.repo_url }}/releases/download/${{ needs.get-version.outputs.release_name }}/GestroKey-${{ needs.get-version.outputs.version }}-Linux-Portable.tar.gz) |" >> release_description.md
          echo "" >> release_description.md
          
          # 添加系统要求
          echo "## 系统要求" >> release_description.md
          echo "" >> release_description.md
          echo "- **Windows**: Windows 10/11 64位" >> release_description.md
          echo "- **macOS**: macOS 11.0+ (Big Sur及更高版本)" >> release_description.md
          echo "- **Linux**: 主流桌面发行版 (Ubuntu 20.04+, Fedora 36+, Debian 11+)" >> release_description.md
          echo "" >> release_description.md
          
          # 添加更新日志
          echo -e "${{ steps.generate_changelog.outputs.CHANGELOG }}" >> release_description.md
          
          # 添加构建信息
          echo "" >> release_description.md
          echo "---" >> release_description.md
          echo "" >> release_description.md
          echo "此版本由GitHub Actions自动构建于 $(date '+%Y-%m-%d %H:%M:%S %Z')" >> release_description.md
          
          # 输出完整内容给后续步骤使用
          echo "DESCRIPTION<<EOF" >> $GITHUB_OUTPUT
          cat release_description.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 检查标签是否存在
      - name: 检查标签是否存在
        id: check_tag
        uses: mukunku/tag-exists-action@v1.4.0
        with:
          tag: ${{ needs.get-version.outputs.release_name }}

      # 删除已存在的release和标签
      - name: 删除已存在的release和标签
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "移除已存在的标签: ${{ needs.get-version.outputs.release_name }}"
          
          # 使用GitHub CLI删除release和标签
          gh release delete ${{ needs.get-version.outputs.release_name }} --yes || echo "Release不存在或无法删除"
          
          # 删除远程标签
          git tag -d ${{ needs.get-version.outputs.release_name }} || echo "本地标签不存在"
          git push --delete origin ${{ needs.get-version.outputs.release_name }} || echo "远程标签不存在或无法删除"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      # 当发布正式版或预览版时删除latest标签
      - name: 删除latest标签
        if: needs.get-version.outputs.version_type != 'Development Version'
        run: |
          echo "发布正式版或预览版，删除latest标签"
          
          # 检查latest标签是否存在
          if git ls-remote --tags origin | grep -q "refs/tags/999.999.999-latest"; then
            # 删除GitHub Release
            gh release delete 999.999.999-latest --yes || echo "Release latest不存在或无法删除"
            
            # 删除远程标签
            git push --delete origin 999.999.999-latest || echo "远程标签latest不存在或无法删除"
          else
            # 兼容性检查：也尝试删除旧的latest标签
            if git ls-remote --tags origin | grep -q "refs/tags/latest"; then
              gh release delete latest --yes || echo "Release latest不存在或无法删除"
              git push --delete origin latest || echo "远程标签latest不存在或无法删除"
            else
              echo "标签latest不存在，无需删除"
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 创建并推送标签
      - name: 创建并推送标签
        run: |
          # 创建标签
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          echo "创建标签: ${{ needs.get-version.outputs.release_name }}"
          git tag -a ${{ needs.get-version.outputs.release_name }} -m "Release ${{ needs.get-version.outputs.release_name }}"
          
          # 推送标签
          git push origin ${{ needs.get-version.outputs.release_name }}

      # 创建Release
      - name: 创建Release
        uses: softprops/action-gh-release@v1
        with:
          name: ${{ needs.get-version.outputs.release_name }}
          tag_name: ${{ needs.get-version.outputs.release_name }}
          body: ${{ steps.generate_table.outputs.DESCRIPTION }}
          prerelease: ${{ needs.get-version.outputs.is_prerelease }}
          files: artifacts/*

  # 代码质量检查任务
  code-quality:
    name: 代码质量检查
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.should_build == 'true'
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
      
      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: 安装质量检查工具
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pylint black isort
      
      - name: 运行flake8检查
        run: |
          flake8 src tests --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 src tests --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: 运行pylint检查
        run: |
          pylint --disable=all --enable=unused-import,unused-variable,unused-argument src
          
      - name: 检查代码格式
        run: |
          black --check src tests
          isort --check-only --profile black src tests
          
      - name: 总结代码质量检查
        run: |
          echo "代码质量检查完成"

  # 依赖安全扫描任务
  security-scan:
    name: 依赖安全扫描
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.should_build == 'true'
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
      
      - name: 设置Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'
      
      - name: 安装安全扫描工具
        run: |
          python -m pip install --upgrade pip
          pip install safety bandit
      
      - name: 扫描依赖漏洞
        run: |
          safety check -r requirements.txt --full-report || echo "安全检查发现潜在问题，但允许继续"
      
      - name: 运行代码安全扫描
        run: |
          bandit -r src -f txt -o bandit_results.txt || echo "代码安全扫描发现潜在问题，但允许继续"
          
      - name: 上传扫描结果
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: |
            bandit_results.txt
          retention-days: 7
          
      - name: 总结安全扫描
        run: |
          echo "安全扫描完成，详细结果请查看构建产物"